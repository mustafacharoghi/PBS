### R code for computing Population Branch Statistics (PBS) described in Yi et al., Science, 2010 ###
### Input format follows plink.frq.strat (allele frequency document) generated by Plink 1.9 ###
library(ggplot2)
library(data.table)
library(haploR)
library(ggrepel)
library(R.utils)

    ## 1 INPUT ##
AF.mat.all=fread(file="plink.frq.strat.gz", header=T, sep=" ")
SNP.map=fread(file="PBS_subset.bim", header=F, sep="\t")

colnames(SNP.map)=c("CHR", "SNP", "gen.dist", "POS", "ref", "alt")
all.pop=unique(AF.mat.all$CLST)
ref1=c("CHB.SG", NA, NA, NA)
ref2=c("CEU.SG", NA, NA)
target.pop=c("Tibetan", NA)

    ## 2 SNP count saving ##
num.SNP=length(unique(AF.mat.all$SNP))
ref1.all.count=ref2.all.count=target.all.count=data.frame(count=rep(0,time=num.SNP), hap=rep(0,time=num.SNP))
for(i in 1:length(ref1))
  if(!is.na(ref1[i])){
    AF.mat.subset=AF.mat.all[AF.mat.all$CLST==ref1[i],]
    ref1.all.count$count=ref1.all.count$count+AF.mat.subset$MAC
    ref1.all.count$hap=ref1.all.count$hap+AF.mat.subset$NCHROBS
  }
for(i in 1:length(ref2))
  if(!is.na(ref2[i])){
    AF.mat.subset=AF.mat.all[AF.mat.all$CLST==ref2[i],]
    ref2.all.count$count=ref2.all.count$count+AF.mat.subset$MAC
    ref2.all.count$hap=ref2.all.count$hap+AF.mat.subset$NCHROBS
  }
for(i in 1:length(target.pop))
  if(!is.na(target.pop[i])){
    AF.mat.subset=AF.mat.all[AF.mat.all$CLST==target.pop[i],]
    target.all.count$count=target.all.count$count+AF.mat.subset$MAC
    target.all.count$hap=target.all.count$hap+AF.mat.subset$NCHROBS
  }
  #Quality control: remove all SNPs with missing data
  
all.count.comb=data.frame(
  ref1.count=ref1.all.count$count,
  ref1.hap=ref1.all.count$hap,
  ref2.count=ref2.all.count$count,
  ref2.hap=ref2.all.count$hap,
  target.count=target.all.count$count,
  target.hap=target.all.count$hap
)
all.count.comb=cbind(SNP.map, all.count.comb)
ref1.hapnum=max(all.count.comb$ref1.hap)
ref2.hapnum=max(all.count.comb$ref2.hap)
target.hapnum=max(all.count.comb$target.hap)

r.mis=0.1
all.count.comb=all.count.comb[all.count.comb$ref1.hap>=(1-r.mis)*ref1.hapnum ,]
all.count.comb=all.count.comb[all.count.comb$ref2.hap>=(1-r.mis)*ref2.hapnum ,]
all.count.comb=all.count.comb[all.count.comb$ref1.count>0 ,]
all.count.comb=all.count.comb[all.count.comb$ref2.count>0 ,]
all.count.comb=all.count.comb[all.count.comb$target.count>0 ,]

    ## 3 PBS calculation ##
fst.calc=function(count.a, hap.a, count.b, hap.b){
  p=(count.a+count.b)/(hap.a+hap.b) #average allele frequency of two pops
  p.a=count.a/hap.a
  p.b=count.b/hap.b
  c.a=hap.a/(hap.a+hap.b)
  c.b=hap.b/(hap.a+hap.b)
  return( (c.a*(p.a-p)^2 + c.b*(p.b-p)^2) / (p*(1-p)) )
}

fst.ref1_ref2=fst.calc(all.count.comb$ref1.count, all.count.comb$ref1.hap, all.count.comb$ref2.count, all.count.comb$ref2.hap)
fst.ref1_target=fst.calc(all.count.comb$ref1.count, all.count.comb$ref1.hap, all.count.comb$target.count, all.count.comb$target.hap)
fst.ref2_target=fst.calc(all.count.comb$ref2.count, all.count.comb$ref2.hap, all.count.comb$target.count, all.count.comb$target.hap)
T.ref1_ref2=-log(1-fst.ref1_ref2)
T.ref1_target=-log(1-fst.ref1_target)
T.ref2_target=-log(1-fst.ref2_target)
PBS=(T.ref1_target+T.ref2_target-T.ref1_ref2)/2
all.count.comb=cbind(all.count.comb, fst.ref1_ref2, fst.ref1_target, fst.ref2_target, PBS)

    ## 4 Annotation ##
all.count.comb.ordered=all.count.comb[order(-all.count.comb$PBS),]
all.count.comb.sig=all.count.comb.ordered[1:100,] #Top 100 SNPs with highest PBS
all.count.comb.sig=all.count.comb.sig[order(all.count.comb.sig$CHR, all.count.comb.sig$POS)]
max.haplo.dist=1e+06
annot.gene=data.frame(
  chrom=all.count.comb.sig$CHR,
  pos=all.count.comb.sig$POS,
  rs_id.overlap=all.count.comb.sig$SNP,
  PBS=all.count.comb.sig$PBS
)  
annot.gene$is.haploblock.prev=annot.gene$is.haploblock.subs=rep(FALSE, time=dim(annot.gene)[1])
for(k in 1:dim(annot.gene)[1]){
  if(k>1 && annot.gene$chrom[k]==annot.gene$chrom[k-1] && annot.gene$pos[k]-annot.gene$pos[k-1]<max.haplo.dist)
    annot.gene$is.haploblock.prev[k]=TRUE
  if(k<dim(annot.gene)[1] && annot.gene$chrom[k]==annot.gene$chrom[k+1] && annot.gene$pos[k+1]-annot.gene$pos[k]<max.haplo.dist)
    annot.gene$is.haploblock.subs[k]=TRUE
}
annot.gene$order.haploplock=rep(0, dim(annot.gene)[1])
total.haploblock=0
for(k in 1:dim(annot.gene)[1]){
  if(annot.gene$is.haploblock.subs[k] && (!annot.gene$is.haploblock.prev[k])){
    total.haploblock=total.haploblock+1
    annot.gene$order.haploplock[k]=total.haploblock
  }
  else if(annot.gene$is.haploblock.prev[k]) annot.gene$order.haploplock[k]=total.haploblock
}
annot.gene=annot.gene[annot.gene$order.haploplock>0,]
# Query of each SNP in haploblock
annot.gene=annot.gene[ substring(annot.gene$rs_id.overlap,1,2)=="rs",]

annot.gene$GENCODE_name=annot.gene$GENCODE_direc=annot.gene$GENCODE_dist=
  annot.gene$RefSeq_name=annot.gene$RefSeq_direc=annot.gene$RefSeq_dist=rep(NA, dim(annot.gene)[1])  
for(i in 1:dim(annot.gene)[1]){
  query_i=queryHaploreg(query=annot.gene$rs_id.overlap[i], querySNP=TRUE)
  annot.gene$GENCODE_name[i]=query_i$GENCODE_name
  annot.gene$GENCODE_direc[i]=query_i$GENCODE_direction
  annot.gene$GENCODE_dist[i]=query_i$GENCODE_distance
  annot.gene$RefSeq_name[i]=query_i$RefSeq_name
  annot.gene$RefSeq_direc[i]=query_i$RefSeq_direction
  annot.gene$RefSeq_dist[i]=query_i$RefSeq_distance  
}
# Top SNP for every significant haploblock
annot.gene$is.top.snp=rep(FALSE, time=dim(annot.gene)[1])
haploblock.list=unique(annot.gene$order.haploplock)
for(k in 1:length(haploblock.list)){
  haploblock_k=annot.gene[annot.gene$order.haploplock==k,]
  max_log.neg.p=max(haploblock_k$PBS)
  top_snp=haploblock_k[haploblock_k$PBS==max_log.neg.p,]$rs_id.overlap
  annot.gene[annot.gene$rs_id.overlap==top_snp[1],]$is.top.snp=TRUE
}
annot.top.snp=annot.gene[annot.gene$is.top.snp,]

    ## 5 Manhattan Plot ## 
# Using physical distance
score.manhattan=data.frame(
  chrom=all.count.comb$CHR,
  pos=all.count.comb$POS,
  rs_id.overlap=all.count.comb$SNP,
  PBS=all.count.comb$PBS
) 
chr.seq=data.frame(chr=unique(score.manhattan$chrom))
chr.seq$max_pos=chr.seq$acc_pos=rep(NA, time=dim(chr.seq)[1])
accum.dist=0
for(i in 1:dim(chr.seq)[1]){ 
  chr.seq$max_pos[i]=max(score.manhattan[score.manhattan$chrom==i,]$pos)
  chr.seq$acc_pos[i]=accum.dist
  accum.dist=accum.dist+chr.seq$max_pos[i]
}
score.manhattan$accum.pos=score.manhattan$pos+chr.seq$acc_pos[score.manhattan$chrom]
chr.vec=aggregate(score.manhattan$accum.pos, by=list(score.manhattan$chrom), FUN=median) #breaks of each chr as median 
score.manhattan$chrom=as.factor(score.manhattan$chrom)

# Adding top SNPs and corresponding genes
score.manhattan$is.top.snp=score.manhattan$is.near.by=rep(FALSE, time=dim(score.manhattan)[1])
score.manhattan$gene=score.manhattan$haploblock=as.character(rep(NA, time=dim(score.manhattan)[1]))
# Annotating nearby SNPs of top selected SNPs (i.e., dist. <1Mb) in main Manhattan file 
for (k in 1:dim(annot.top.snp)[1]){
  annot.snp=annot.top.snp[k,]
  score.manhattan[score.manhattan$rs_id.overlap==annot.snp$rs_id.overlap,]$is.top.snp=TRUE
  score.manhattan[score.manhattan$rs_id.overlap==annot.snp$rs_id.overlap,]$gene=annot.snp$GENCODE_name
  nearby.snps=intersect(which(score.manhattan$chrom==annot.snp$chrom), which(abs(score.manhattan$pos-annot.snp$pos)<max.haplo.dist))
  score.manhattan[nearby.snps,]$is.near.by=TRUE
  score.manhattan[nearby.snps,]$haploblock=k
}

p_manhattan=
  ggplot(data=score.manhattan, aes(x=accum.pos, y=PBS))+
  geom_hline(yintercept=min(all.count.comb.sig$PBS), color="darkred", linetype="dashed")+#significant line
  geom_point(aes(color=chrom), show.legend=FALSE)+
  scale_color_manual(values=rep(c("deepskyblue", "dodgerblue4"), as.integer(dim(chr.vec)[1]/2)))+
  geom_point(data=subset(score.manhattan, is.near.by==TRUE), size=4, color="gold")+
  geom_text_repel(data=subset(score.manhattan, is.top.snp==TRUE), aes(label=gene), hjust=0, vjust=0.5, angle=90, size=5, max.overlaps=Inf, fontface="italic" )+
  scale_x_continuous(breaks=chr.vec$x, labels=chr.vec$Group.1, expand = c(0, 0))+
  scale_y_continuous(limits=c(min(score.manhattan$PBS)-0.02, max(score.manhattan$PBS)+0.02), expand=c(0,0))+
  theme_bw()+xlab("chromosome")+ylab("PBS") +
  theme(panel.grid.major=element_blank(), 
        panel.grid.minor=element_blank(),
        axis.title=element_text(size=12))
prefix=paste(target.pop[1], "ref1", ref1[1], "ref2", ref2[1], sep="_")

ggsave(p_manhattan, file=paste(prefix, "_PBS", "_Manhattan.pdf", sep=""), height=8, width=15)
FST_info=all.count.comb[match(annot.gene$rs_id.overlap, all.count.comb$SNP),7:15]
write.table(cbind(annot.gene,FST_info), file=paste(prefix, "_PBS", "_results.txt", sep=""), quote=F, append=F, row.names=F, col.names=T)
pops=rbind(ref1,ref2,target.pop)
write.table(pops, file=paste(prefix, "_PBS", ".log", sep=""), quote=F, append=F, row.names=T, col.names=F)
write.table(paste("SNP after filtering=", dim(all.count.comb)[1]), file=paste(prefix, "_PBS", ".log", sep=""), quote=F, append=T, row.names=F, col.names=F)
